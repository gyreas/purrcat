import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class GetLines {
  // private static char[] cbuf = new char[BUF_SIZE];
  // private static final int BUF_SIZE = 8192
  // private static int origin = 0;
  // private static int offset = 0;
  // private static int i = 0;
  // private static int end;

  static void getlines(BufferedReader rd) throws IOException {
    PrintWriter writer = new PrintWriter(System.out);
    char[] cbuf = new char[2048];

    int end = rd.read(cbuf);
    // each read
    while (end != -1) {
      int origin = 0;
      int i = 0;
      int offset = 0;

      // go through the buffer
      while (i < end) {
        char ch = cbuf[i];
        if (ch == '\n') {
          offset = i - origin;
          writer.write(cbuf, origin, offset + 1);
          origin = i + 1;
        }
        i++;
      }
      end = rd.read(cbuf);
    }
    writer.flush();
  }

  public static void main(String[] args) throws IOException {
    Path file = Paths.get(args[0]);
    var buf = Files.newBufferedReader(file);
    getlines(buf);
  }
}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.*;
import java.util.regex.*;

public class Grep {

  // Charset and decoder for ISO-8859-15
  private static Charset charset = Charset.forName("ISO-8859-15");
  private static CharsetDecoder decoder = charset.newDecoder();

  // Pattern used to parse lines
  private static Pattern linePattern = Pattern.compile(".*\r?\n");

  // The input pattern that we're looking for
  private static Pattern pattern;

  // Compile the pattern from the command line
  private static void compile(String pat) {
    try {
      pattern = Pattern.compile(pat);
    } catch (PatternSyntaxException x) {
      System.err.println(x.getMessage());
      System.exit(1);
    }
  }

  // Use the linePattern to break the given CharBuffer into lines, applying
  // the input pattern to each line to see if we have a match
  private static void grep(File f, CharBuffer cb) {
    Matcher lm = linePattern.matcher(cb); // Line matcher
    Matcher pm = null; // Pattern matcher
    int lines = 0;
    while (lm.find()) {
      lines++;
      CharSequence cs = lm.group(); // The current line
      if (pm == null) pm = pattern.matcher(cs);
      else pm.reset(cs);
      if (pm.find()) System.out.print(f + ":" + lines + ":" + cs);
      if (lm.end() == cb.limit()) break;
    }
  }

  // Search for occurrences of the input pattern in the given file
  private static void grep(File f) throws IOException {

    // Open the file and then get a channel from the stream
    try (FileInputStream fis = new FileInputStream(f);
        FileChannel fc = fis.getChannel()) {

      // Get the file's size and then map it into memory
      int sz = (int) fc.size();
      MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

      // Decode the file into a char buffer
      CharBuffer cb = decoder.decode(bb);

      // Perform the search
      grep(f, cb);
    }
  }

  public static void main(String[] args) {
    if (args.length < 2) {
      System.err.println("Usage: java Grep pattern file...");
      return;
    }
    compile(args[0]);
    for (int i = 1; i < args.length; i++) {
      File f = new File(args[i]);
      try {
        grep(f);
      } catch (IOException x) {
        System.err.println(f + ": " + x);
      }
    }
  }
}
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.CharBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Buf {
  public static void main(String[] args) throws IOException {
    final int BUF_SIZE = 8 * 1024;
    String filename = args[0]; // "all.txt";
    BufferedReader reader = Files.newBufferedReader(Paths.get(filename));
    CharBuffer cbuf = CharBuffer.allocate(BUF_SIZE);

    System.out.println("READ ALL BYTES: ");
    int amt = 0;
    while (true) {
      amt = reader.read(cbuf.array(), 0, BUF_SIZE);
      if (amt == -1) break;
      System.out.print(cbuf.subSequence(0, amt));
    }
  }

  public static String read_line(CharBuffer buf) {
    int hasLine = detect_line_ending(buf.array());
    // if line is detected
    if (hasLine == -1) return
  }
  // algorithm
  // 1. Go through the buffer
  // 2. If it's EOL, return index else return -1
  public static int detect_line_ending(char[] buf) {
    int i = 0;
    int nlines = 0;
    while (i < buf.length) {
      if (buf[i] == '\r' && buf[i + 1] == '\n') {
        nlines++;
        i += 1;
        break;
      } else if (buf[i] == '\r' || buf[i] == '\n') {
        nlines++;
        break;
      } else {
        i++;
      }
    }
    if (nlines == 0) return -1;
    else return i;
  }

  public static String read_to_string(String filename) {
    // Charset charset = Charset.forName("US-ASCII");
    String content = null;

    try {
      content = Files.readString(Paths.get(filename));
    } catch (IOException x) {
      System.err.format("Unable to read %s %n", filename);
    }

    if (content == null) return "";
    else return content; /* file */
  }
}
